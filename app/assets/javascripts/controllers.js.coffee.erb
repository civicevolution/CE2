# Place all the behaviors and hooks related to the matching controller here.
# All this logic will automatically be available in application.js.
# You can use CoffeeScript in this file: http://jashkenas.github.com/coffee-script/

bootstrap_CE2 = ->
	#console.log "In bootstrap_CE2"

  if typeof Firebase == 'undefined'
    setTimeout bootstrap_CE2, 50
  else
    try
      angular.bootstrap(document,["CE2"])
    catch error
      setTimeout bootstrap_CE2, 50

bootstrap_CE2()


ce2_app = angular.module("CE2", ["ngResource","CE2.services", 'CE2.directives', 'CE2.filters',
  'ui.compat', 'ui.bootstrap'] )

ce2_app.config ($httpProvider) ->
	$httpProvider.defaults.headers.common["X-CSRF-TOKEN"] =
		document.querySelectorAll('meta[name="csrf-token"]')[0].getAttribute('content')


ce2_app.factory 'errorHttpInterceptor', ($q, $injector) ->
  (promise) ->
    promise.then (response) ->
      # do something on success
      #console.log "$httpProvider.responseInterceptors Success"
      promise # pass the promise on to the calling function
    , (response) ->
      # do something on error
      if (canRecover(response))
        return promise # let the response promise continue and be dealt with
      $dialog = $dialog || $injector.get("$dialog")
      switch response.data.class
        when "CanCan::AccessDenied"
          title = 'Access denied'
          msg = "Sorry, you are not authorized for this action [URL: #{response.config.url}, Controller: #{response.data.controller}, Action: #{response.data.action}]"
        else
          title = 'Server error'
          msg = "#{response.data.error} [URL: #{response.config.url}, Controller: #{response.data.controller}, Action: #{response.data.action}]"
      btns = [{result:'ok', label: 'OK', cssClass: 'btn-primary'}]
      $dialog.messageBox(title, msg, btns).open()
      #console.log "XXX $httpProvider.responseInterceptors Error\n#{response.data.error}"
      return $q.reject(response)
canRecover = (response) ->
  #if response.data.class?.match(/CanCan/)
  #  return false
  switch
    when response.config.url.match(/guest_posts/) && response.data.class is "ActiveRecord::RecordNotFound" then true
    when response.data.class then false
    when response.data.errors then true
    else false



ce2_app.config ($httpProvider) ->
  $httpProvider.responseInterceptors.push('errorHttpInterceptor')

ce2_app.value('Firebase', Firebase);

ce2_app.config ( [ '$stateProvider', '$urlRouterProvider',
  ($stateProvider, $urlRouterProvider) ->

    $urlRouterProvider
      # provides redirects
      .when('/c?id', '/contacts/:id')
      .otherwise('/home');
      #.otherwise('/iap2');

    $stateProvider
      # registers the urls with $urlRouterProvider
      .state('home', {
        url: '/home',
        templateUrl: '<%= path_to_asset "home.html" %>'
        resolve:
          conversations: ["ConversationData", (ConversationData) ->
            ConversationData.conversations()
          ]
        controller: [ "$scope", "conversations", "ConversationData", "$state",
          ($scope, conversations, ConversationData, $state) ->
            #console.log "In home state controller"
            $scope.conversations = conversations
            $scope.create_conversation = ->
              #console.log "create a new conversation and nav to it or show error"
              ConversationData.create_new_conversation().then (response) ->
                #console.log "RoR response to ConversationData.create_new_conversation with code: #{response.data.code}"
                $state.transitionTo('conversation', {code: response.data.code, munged_title: "new"})
        ]
      })

      .state( 'conversation',
        url: "/conversation/{code}/{munged_title}"
        #url: "/conversation/{code}/{munged_title:[^/]*}{path:.*}"
        templateUrl: '<%= path_to_asset "conversation.html" %>'
        resolve:
          conversation: ["ConversationData", "$stateParams", (ConversationData, $stateParams) ->
                         console.log "resolve get ConversationData.conversation"
                         ConversationData.conversation($stateParams.code)
            #console.log "conversation state with path: #{$stateParams.path}"
          ]
        controller: conversation_controller
      )


      .state( 'live-conversation-group',
          url: "/conversation/{code}/group/{munged_title}"
          templateUrl: '<%= path_to_asset "live/group.html" %>'
          resolve:
            conversation_group_data: ["LiveGroupData", "$stateParams", (LiveGroupData, $stateParams) ->
              console.log "resolve get LiveGroupData.conversation_group_data"
              LiveGroupData.conversation_group_data($stateParams.code)
            ]
            conversations: ["LiveData", "$stateParams", (LiveData, $stateParams) ->
              LiveData.conversations()
            ]
          controller: conversation_group_controller
        )


      .state( 'live-conversation-theme',
        url: "/conversation/{code}/theme/{munged_title}"
        templateUrl: '<%= path_to_asset "live/theme.html" %>'
        resolve:
          conversation_theme_data: ["ThemeData", "$stateParams", (ThemeData, $stateParams) ->
            console.log "resolve get ConversationData.theme"
            ThemeData.conversation_theme_data($stateParams.code)
            #console.log "conversation state with path: #{$stateParams.path}"
          ]
        controller: conversation_theme_controller
      )

      # http://app.civicevolution.dev:8001/#/conversation/tfxdeqclv3/themes/xyz
      .state('live-themes',
        url: "/conversation/{code}/themes/{munged_title}"
        templateUrl: '<%= path_to_asset "live/themes.html" %>'
        resolve:
          conversation_title: ["ConversationData", "$stateParams", (ConversationData, $stateParams) ->
            ConversationData.title($stateParams.code).then(
              (response)->
                response.data
            )
          ]
          conversation_themes: ["ThemeData", "$stateParams", (ThemeData, $stateParams) ->
            ThemeData.conversation_themes($stateParams.code).then(
              (response)->
                letter_ctr = 0;
                themes = response.data.sort((a,b)-> a.order_id - b.order_id)
                for comment in themes
                  comment.letter = String.fromCharCode('A'.charCodeAt() + letter_ctr)
                  letter_ctr += 1
                themes
            )
          ]

        onEnter: ->
          angular.element(document.body).addClass('display-page')
        onExit: ->
          angular.element(document.body).removeClass('display-page')

        controller: [ "$scope", "conversation_themes", "$location", "conversation_title", "$compile", "$timeout",
          ($scope, conversation_themes, $location, conversation_title, $compile, $timeout) ->
            $scope.conversation_title = conversation_title
            $scope.conversation_themes = conversation_themes
            $scope.$root.initialize_markdown_system( {disable_editor: true} )
            $scope.no_examples = $location.search()['ex'] == '0'
            if not $scope.no_examples
              #console.log "compile the blockquotes"
              $timeout ->
                $scope.theme_display_only = true
                $compile(angular.element(document.body).find('blockquote'))($scope)
              ,1000

        ]
      )


      # http://app.civicevolution.dev:8001/#/conversation/tfxdeqclv3/choose/xyz
      .state( 'live-theme-choose',
        url: "/conversation/{code}/choose/{munged_title}"
        templateUrl: '<%= path_to_asset "live/choose.html" %>'
        resolve:
          conversations_and_themes: ["LiveData", "$stateParams", (LiveData, $stateParams) ->
            LiveData.conversations_and_themes($stateParams.code).then(
              (response)->
                for question in response.data
                  letter_ctr = 0;
                  for theme in question.theme_comments
                    theme.letter = String.fromCharCode('A'.charCodeAt() + letter_ctr)
                    letter_ctr += 1
                response.data
            )
          ]
        controller: live_choice_controller
      )

      # http://app.civicevolution.dev:8001/#/conversation/tfxdeqclv3/choose-results/xyz
      .state('live-choose-results',
        url: "/conversation/{code}/choose-results/{munged_title}"
        templateUrl: '<%= path_to_asset "live/choose-results.html" %>'
        resolve:
          conversation_title: ["ConversationData", "$stateParams", (ConversationData, $stateParams) ->
            ConversationData.title($stateParams.code).then(
              (response)->
                response.data
            )
          ]
          theme_votes: ["LiveData", "$stateParams", (LiveData, $stateParams) ->
            LiveData.theme_votes($stateParams.code).then(
              (response)->
                response.data
            )
          ]
        onEnter: ->
          angular.element(document.body).addClass('display-page')
        onExit: ->
          angular.element(document.body).removeClass('display-page')

        controller: [ "$scope", "theme_votes", "conversation_title",
          ($scope, theme_votes, conversation_title) ->
            $scope.theme_votes = theme_votes
            $scope.conversation_title = conversation_title
            $scope.$root.initialize_markdown_system( {disable_editor: true} )
        ]
      )

      # http://app.civicevolution.dev:8001/#/live/tfxdeqclv3/options
      .state('live-options',
        url: "/live/{code}/options"
        templateUrl: '<%= path_to_asset "live/options.html" %>'
        resolve:
          allocation_themes: ["LiveAllocateData", "$stateParams", (LiveAllocateData, $stateParams) ->
            LiveAllocateData.allocation_themes($stateParams.code)
          ]
        onEnter: ->
          angular.element(document.body).addClass('display-page')
        onExit: ->
          angular.element(document.body).removeClass('display-page')
        controller: [ "$scope", "allocation_themes",
          ($scope, allocation_themes) ->
            $scope.allocation_themes = allocation_themes
            $scope.$root.initialize_markdown_system( {disable_editor: true} )
        ]

      )

      # http://app.civicevolution.dev:8001/#/live/tfxdeqclv3/allocate
      .state( 'live-theme-allocate',
        url: "/live/{code}/allocate"
        templateUrl: '<%= path_to_asset "live/allocate.html" %>'
        resolve:
          allocation_themes: ["LiveAllocateData", "$stateParams", (LiveAllocateData, $stateParams) ->
            LiveAllocateData.allocation_themes($stateParams.code)
          ]
          code: ["$stateParams", ($stateParams) ->
            $stateParams.code
          ]
        controller: live_allocate_controller
      )

      # http://app.civicevolution.dev:8001/#/live/tfxdeqclv3/allocate-results
      .state('live-allocate-results',
        url: "/live/{code}/allocate-results"
        templateUrl: '<%= path_to_asset "live/allocate-results.html" %>'
        resolve:
          allocated_points: ["LiveAllocateData", "$stateParams", (LiveAllocateData, $stateParams) ->
            LiveAllocateData.allocated_points($stateParams.code)
          ]
        onEnter: ->
          angular.element(document.body).addClass('display-page')
        onExit: ->
          angular.element(document.body).removeClass('display-page')
        controller: [ "$scope", "allocated_points",
          ($scope, allocated_points) ->
            $scope.allocated_points = allocated_points
            $scope.$root.initialize_markdown_system( {disable_editor: true} )
        ]
      )

      .state('iap2',
        url: '/iap2'
        templateUrl: '<%= path_to_asset "iap2.html" %>'
        resolve:
          conversations: ["LiveData", "$stateParams", (LiveData, $stateParams) ->
            LiveData.conversations()
          ]
        controller: [ "$scope", "conversations",
          ($scope, conversations) ->
            $scope.conversations = conversations
            $scope.$root.initialize_markdown_system( {disable_editor: true} )
        ]
      )

      .state('about', {
        url: '/about',
        templateProvider:
          [        '$timeout', ($timeout) ->
            $timeout ->
              "Hello <i>world</i>"
            , 100
          ]
      })

      .state('edit-profile', {
        url: '/edit-profile'
        templateUrl: '<%= path_to_asset "edit-profile.html" %>'
      })

])

ce2_app.run( ['$rootScope', '$state', '$stateParams', "$timeout", "$http", "$templateCache", "$dialog", "$location",
  ($rootScope,   $state,   $stateParams, $timeout, $http, $templateCache, $dialog, $location) ->
    $rootScope.dev_mode = if $location.host().match(/dev$/) then true else false
    $rootScope.$state = $state
    $rootScope.$stateParams = $stateParams
    $rootScope.CSRF = document.querySelectorAll('meta[name="csrf-token"]')[0].getAttribute('content')

    $rootScope.$on '$stateChangeError', (event, toState, toParams, fromState, fromParams, error) ->
      console.log "$stateChangeError tostate: #{toState.url}, fromState: #{fromState.url}"
    $rootScope.$on '$stateChangeStart', (event, toState, toParams, fromState, fromParams) ->
      console.log "$stateChangeStart tostate: #{toState.url}, fromState: #{fromState.url}"
    $rootScope.$on '$stateChangeSuccess', (event, toState, toParams, fromState, fromParams) ->
      console.log "$stateChangeSuccess tostate: #{toState.url}, fromState: #{fromState.url}"

    $rootScope.$on '$viewContentLoaded', (obj) ->
      console.log "$viewContentLoaded"

    $rootScope.initialize_markdown_system = (options) ->
      #console.log "initialize_markdown_system"
      # which will call initialize_markdown_editor
      if Markdown
        initialize_markdown_converter( $timeout, $dialog, $rootScope, options )
      else
        $timeout ->
          $rootScope.initialize_markdown_system(options)
        ,300

    $http.get("<%= path_to_asset "quote.html" %>", {cache:$templateCache};)

])

initialize_markdown_converter = ($timeout, $dialog, $rootScope, options) ->
  quoteTemplate = null

  disable_editor = if options && options.disable_editor then true else false

  #converter = new Markdown.getSanitizingConverter()
  # Since I am using hooks, I will manually hook in sanitize at the end
  converter = new Markdown.Converter();
  editor = new Markdown.Editor(converter) unless disable_editor

  # Before cooking callbacks
  converter.hooks.chain "preConversion", (text) ->
    #Discourse.Markdown.trigger('beforeCook', { detail: text, opts: opts });
    #return Discourse.Markdown.textResult || text;
    return text

  # Extract quotes so their contents are not passed through markdown.
  converter.hooks.chain "preConversion", (text) ->
    extracted = Markdown.BBCode.extractQuotes(text)
    quoteTemplate = extracted.template;
    return extracted.text;

  converter.hooks.chain "postConversion", (text) ->
    # reapply quotes
    text = quoteTemplate(text) if quoteTemplate
    return Markdown.BBCode.format(text);

  Markdown.upload_dialog = (linkEnteredCallback) ->
    console.log "call the upload dialog"

    dialog = $dialog.dialog(
      backdrop: true
      keyboard: true
      backdropClick: true
      templateUrl: '<%= path_to_asset "insert-image-form.html" %>'
      controller: ["$scope", "$timeout", ($scope, $timeout) ->
        debug = false
        $scope.type = 'local'
        $scope.image = {conversation_code: angular.element(document.getElementById('wmd-input')).scope().conversation.code }

        console.log "in dialog, $scope.image.conversation_id: #{$scope.image.conversation_id} "

        $scope.show_tab = (str) ->
          if str is 'web'
            console.log "show web tab"
            $scope.type = 'web'
          else
            console.log "show local tab"
            $scope.type = 'local'
        $scope.submit = ->
          console.log "submit url: #{$scope.image.url}"
          linkEnteredCallback($scope.image.url)
          dialog.close()

        $scope.upload = ->
          console.log "upload file"
          file_input = document.getElementById('filename-input')
          if file_input.files.length > 0
            file_name = file_input.files[0].name
            console.log "loading file: #{file_name}" if debug
            $scope.progress_bar_message = "<i class='icon-spinner icon-spin'></i><span>Loading #{file_name}</span>"
            image_upload_form.submit()

        $scope.iframe_loaded = (el) ->
          # have access to $scope here
          console.log "ceCommentForm: window.iframe_loaded, get the contents" if debug

          content = el.contentDocument.body.innerText
          if content
            attachment = angular.fromJson(content)
            console.log "in_page_url is #{attachment.in_page_url}"
            $timeout ->
              linkEnteredCallback(attachment.in_page_url, {width: attachment.image_width, height: attachment.image_height});
              dialog.close()
              $scope.$root.$broadcast('update-new-comment-text')

        $scope.cancel = ->
          dialog.close()
      ]
    )
    dialog.open()
    $rootScope.$$phase || $rootScope.$apply()
  unless disable_editor
    $timeout ->
      $rootScope.$broadcast 'initialize-markdown-editor', {editor: editor}
    , 1000
  $rootScope.converter = converter
  $rootScope.editor = editor unless disable_editor


conversation_controller = [ "$scope", "conversation", "FirebaseService", "$timeout", "ConversationData", "$dialog",
  ($scope, conversation, FirebaseService, $timeout, ConversationData, $dialog) ->
    console.log "In conversation state controller at bottom"
    $scope.conversation = conversation
    $scope.$root.timestamp = conversation.current_timestamp

    $scope.name = 'ceConversation'
    # the data was resolved and attached to scope in the state definition
    
    $timeout ->
      if $scope.conversation.role == 'conversation_admin' && !$scope.conversation.published
        $scope.conversation.wizard_mode = true

      if $scope.conversation.can('show_participants')
        ConversationData.load_stats($scope.conversation.code).then(
          (response)->
            for key of response.data
              $scope.conversation[key] = response.data[key]
          )
    , 1000

    $scope.show_comment_form = (action) ->
      $scope.$root.$broadcast 'open-comment-form', {action: action}

    # Subscribe to updates for this data
    url = "https://civicevolution.firebaseio.com/conversations/#{$scope.conversation.code}/updates/"
    #console.log "firebase url: #{url}"
    FirebaseService.initialize_source(url, $scope.conversation.firebase_token)

    # register the listeners for the firebase updates
    $scope.$on 'ConversationComment_update', (event, data) ->
      #console.log "received broadcast ConversationComment_update"
      [original_rec, updated_rec] = FirebaseService.process_update($scope.conversation.conversation_comments, data)
      if updated_rec && original_rec
        updated_rec.editable_by_user = original_rec.editable_by_user || updated_rec.editable_by_user
        if updated_rec.purpose isnt original_rec.purpose
          console.log "update the graph to show new labels"
          element = angular.element(document.getElementById("com-#{updated_rec.id}"))
          canvas = element.find('canvas')
          canvas.scope().redraw_rating_graph( element )

    $scope.$on 'SummaryComment_update', (event, data) ->
      #console.log "received broadcast SummaryComment_update"
      [original_rec, updated_rec] = FirebaseService.process_update($scope.conversation.summary_comments, data)
      if updated_rec && original_rec
        updated_rec.editable_by_user = original_rec.editable_by_user || updated_rec.editable_by_user

    $scope.$on 'RatingsCache_update', (event, data) ->
      #console.log "received broadcast RatingsCache_update"
      data = data.data
      item_array = switch data.type
        when "SummaryComment" then $scope.conversation.summary_comments
        when "ConversationComment" then $scope.conversation.conversation_comments
      if item_array
        for rec in item_array
          if rec.id == data.id
            comment = rec
            break
        if comment
          #console.log "Update the ratings on comment id: #{comment.id}"
          comment.number_of_votes = data.number_of_votes
          comment.ratings_cache = data.ratings_cache
          $scope.$$phase || $scope.$apply()


    $scope.$on 'CallToActionComment_update', (event, data) ->
      #console.log "received broadcast CallToActionComment_update"
      if not $scope.conversation.call_to_action_comment
        # is user the curator? must be as conversation cannot be pusblished without a cta
        $scope.conversation.call_to_action_comment = { editable_by_user: true }
      editable_by_user = $scope.conversation.call_to_action_comment.editable_by_user
      $scope.conversation.call_to_action_comment[prop] = data.data[prop] for prop of data.data when not prop.match(/^\$/)
      $scope.conversation.call_to_action_comment.editable_by_user = editable_by_user
      $scope.$$phase || $scope.$apply()

    $scope.ConversationCommentLength = 1500
    $scope.SummaryCommentLength = 0

    # register a listener for summary_comments ordered ids
    $scope.$on 'Conversation_update', (event, data) ->
      #console.log "received broadcast Conversation_update"

      # make sure it is the correct conversation_id
      # $scope.conversation.id
      if Number(data.data.conversation_id) is Number($scope.conversation.id)
        ordered_ids = data.data.ordered_ids
        # reorder $scope.conversation.summary_comments according to these ids
        if ordered_ids
          # update the order_id for the comments
          for comment in $scope.conversation.summary_comments
            comment.order_id = ordered_ids[comment.id]
          #resort the summary_comments according to order_id
          $scope.conversation.summary_comments.sort((a, b) -> return a.order_id > b.order_id )
        $scope.$$phase || $scope.$apply()

    $scope.edit_title = ->
      #console.log "edit the title"
      $scope.title_temp = $scope.conversation.title
      $scope.conversation.edit_title = true
      $scope.$root.$broadcast "user-event-notification", { action: 'open title edit'}

    $scope.save_title = ->
      ConversationData.save_title($scope.conversation.code, $scope.conversation.title).then (response) ->
        #console.log "return from save_title"
        $scope.conversation.title = response.data.text
        $scope.conversation.edit_title = false
        $scope.$root.$broadcast "user-event-notification", { action: 'save title edit'}

    $scope.cancel_title_edit = ->
      $scope.conversation.title = $scope.title_temp
      $scope.conversation.edit_title = false

    $scope.$on 'Publish conversation', (event, data) ->
      #console.log "publishConversation with code: #{data.conversation_code}"
      button_scope = data.button_scope
      button_scope.form_submit_status = 'Publishing <i class="icon-spinner icon-spin"></i>'
      ConversationData.publish_conversation(data.conversation_code).then (response)->
        #console.log "ConversationData.publish_conversation received response"
        button_scope.form_submit_status = 'Published'
        $timeout ->
          #button_scope.form_submit_status = 'Publish'
          $scope.$root.$broadcast "user-event-notification", { action: 'conversation published'}
        ,800


]

ce2_app.controller 'ActivityMonitorController', ($scope, User, $dialog) ->
  $scope.name = 'ActivityMonitor'
  $scope.$on 'user-clicked-dead-link', (event, data) ->
    console.log "'user-clicked-dead-link' for action: #{data.action}"
    #data.conversation_code = $scope.
    #{ action: 'Share'}
    title = "Sorry, this feature isn't quite ready yet"
    msg = "We are working on this feature now. Please click the \"Contact Us\" link on the right side of the page to share your ideas about how to make CivicEvolution better!"
    btns = [{result:'ok', label: 'OK', cssClass: 'btn-primary'}]
    $dialog.messageBox(title, msg, btns).open()

    User.send_activity_report(data).then(
      (response)->
        #console.log "send_activity_report was successful"
      ,
      (reason) ->
        console.log "send_activity_report failed: #{reason.data.error}"
    )


conversation_theme_controller = [ "$scope", "conversation_theme_data", "FirebaseService", "$timeout", "$dialog", "ThemeData",
  ($scope, conversation_theme_data, FirebaseService, $timeout, $dialog, ThemeData) ->
    console.log "In conversation state controller at bottom"
    $scope.conversation = conversation_theme_data
    $scope.$root.timestamp = conversation_theme_data.current_timestamp

    $scope.name = 'ceConversationTheme'

    $timeout ->
      $scope.conversation.filter_mode = 'themes'
      $scope.refilter_table_comments()
      $scope.$root.$broadcast 'calculate-tag-counts'
      $scope.$root.$broadcast 'update-comment-tags'
    , 500

    # Subscribe to updates for this data
    url = "https://civicevolution.firebaseio.com/conversations/#{$scope.conversation.code}/updates/"
    #console.log "firebase url: #{url}"
    FirebaseService.initialize_source(url, $scope.conversation.firebase_token)

    $scope.$on 'TableComment_update', (event, data) ->
      data.data.reference_ids = [] unless data.data.reference_ids
      [original_rec, updated_rec] = FirebaseService.process_update($scope.conversation.table_comments, data)
      if updated_rec && original_rec
        updated_rec.editable_by_user = original_rec.editable_by_user || updated_rec.editable_by_user
      if data.action == 'create'
        $timeout ->
          $scope.$root.$broadcast 'calculate-tag-counts'
          $scope.$root.$broadcast 'update-comment-tags', updated_rec
          $scope.refilter_table_comments()
    , 500



    $scope.filter_table_comments = (mode, id=null) ->
      #console.log "filter_table_comments mode: #{mode}, id: #{id}"
      $scope.conversation.filter_mode = mode
      $scope.conversation.filter_id = id
      $scope.refilter_table_comments()

    $scope.refilter_table_comments = () ->
      mode = $scope.conversation.filter_mode
      id = $scope.conversation.filter_id
      console.log "refilter_table_comments mode: #{mode}, id: #{id}"
      switch
        when mode is 'all'
          $scope.conversation.filtered_comments = $scope.conversation.table_comments

        when mode is 'untagged'
          $scope.conversation.filtered_comments = (comment for comment in $scope.conversation.table_comments when comment.tag_bools && comment.tag_bools[0] && comment.status != 'parked' )

        when mode is 'parked'
          $scope.conversation.filtered_comments = (comment for comment in $scope.conversation.table_comments when comment.status == 'parked')

        when mode is 'themes'
          $scope.conversation.filtered_comments = $scope.conversation.theme_comments.sort((a,b)-> a.order_id - b.order_id)

        when mode is 'theme'
          $scope.conversation.current_theme = _.findWhere($scope.conversation.theme_comments, {id: id})
          $scope.conversation.filtered_comments = []
          for id in $scope.conversation.current_theme.ordered_child_ids
            for comment in $scope.conversation.table_comments
              if comment.id is id
                $scope.conversation.filtered_comments.push comment
                break;

        when mode is 'table'
          $scope.conversation.filtered_comments = ( comment for comment in $scope.conversation.table_comments when Number(comment.table_number) is id)

    $scope.$on 'ThemeComment_update', (event, data) ->
      #console.log "received broadcast ThemeComment_update"
      [original_rec, updated_rec] = FirebaseService.process_update($scope.conversation.theme_comments, data)
      if updated_rec && original_rec
        updated_rec.editable_by_user = original_rec.editable_by_user || updated_rec.editable_by_user
      tag_hash = {}
      for comment in $scope.conversation.theme_comments
        tag_hash[comment.id] = comment.tag_name
        if comment.text.match(/\[quote/)
          comment.popover = comment.text.split('[quot')[0]
        else
          comment.popover = comment.text

      $scope.conversation.theme_tag_hash = tag_hash
      # Update the visible tag widgets
      $scope.$root.$broadcast 'update-comment-tags'
      $scope.$root.$broadcast 'calculate-tag-counts'
      
    $scope.edit = (action) ->
      #console.log "Edit with action: #{action} for  #{$scope.conversation.current_theme.tag_name}"
      $scope.$root.$broadcast 'open-comment-form', {action: action, comment: $scope.conversation.current_theme}

    $scope.$on 'text-select-add-example', (event, sel) ->
      #console.log "received broadcast message text-select-add-example"
      example_data =
        quote_type: "example"
        id: sel.comment.id
        name: sel.comment.name
        purpose: sel.comment.purpose
      example_insert = "[quote=#{ angular.toJson(example_data)}]#{sel.text}[/quote]"
      #console.log "Add this example to textarea: #{example_insert}"
      $scope.$root.$broadcast 'open-comment-form', {action: 'add-example-from-selected-text', quote_insert: example_insert, comment: $scope.conversation.current_theme, append_to_existing: true}

    $scope.$on 'update-comment-tags', (event,comment) ->
      comments = if comment then [comment] else $scope.conversation.table_comments
      for comment in comments
        comment.tag_bools = new class then constructor: ->
          if comment.reference_ids.length is 0
            @[0] = true
          else
            @[id] = true for id in comment.reference_ids
        tags = ($scope.conversation.theme_tag_hash[id] for id in comment.reference_ids)
        tags.push 'Parked' if comment.status == 'parked'
        comment.tags = tags.join(', ') || 'Tag this comment'

    $scope.$on 'calculate-tag-counts', ->
      #console.log "calculate-tag-counts"
      counts =
        themes: 0
        all: 0
        untagged: 0
        table1: 0
        table2: 0
        table3: 0
        table4: 0
        parked: 0

      for theme in $scope.conversation.theme_comments
        counts['themes'] += 1
        counts[theme.id] = 0

      for comment in $scope.conversation.table_comments
        counts['all'] += 1
        counts["table#{comment.table_number}"] += 1
        if comment.status == 'parked'
          counts['parked'] += 1
        if comment.reference_ids && comment.reference_ids.length == 0 && comment.status != 'parked'
          counts['untagged'] += 1
        else
          for id in comment.reference_ids
            counts[id] += 1

      for theme in $scope.conversation.theme_comments
        theme.comments = counts[theme.id]

      $scope.conversation.comment_counts = counts
    
    $scope.$on 'theme-comment-delete', (event,data) ->
      theme = data.comment
      console.log "delete this theme comment: #{theme.tag_name}"
      if theme.comments > 0
        btns = [{result:'ok', label: 'OK', cssClass: 'btn-primary'}]
        $dialog.messageBox('Sorry', "Theme can only be deleted if it has no comments", btns).open()
        $scope.$root.$$phase || $scope.$root.$apply()
      else
        console.log "Delete this theme"
        ThemeData.delete(theme).then(
          (response)->
            console.log "theme was deleted successfully"
            if response.data.type
              $scope.$root.$broadcast "#{response.data.type}_update", {
                action: 'delete'
                class: response.data.type
                data: response.data
                updated_at: new Date().getTime()
                source: "theme-comment-delete"
              }
            $timeout ->
              $scope.conversation.filter_mode = 'themes'
              $scope.refilter_table_comments()

        ,
        (reason) ->
          console.log "theme delete failed"
          title = 'Sorry'
          msg = "This theme was not deleted: #{reason.data.error}"
          btns = [{result:'ok', label: 'OK', cssClass: 'btn-primary'}]
          $dialog.messageBox(title, msg, btns).open()
        )
        
    $scope.$on 'show-theme-page', (event, data) ->
      theme = data.comment
      #console.log "show theme page for theme: #{theme.tag_name}"
      $scope.conversation.filter_mode = 'theme'
      $scope.conversation.filter_id = theme.id
      $scope.refilter_table_comments()


]

conversation_group_controller = [ "$scope", "conversation_group_data", "FirebaseService", "$timeout", "$dialog", "LiveGroupData", "conversations",
  ($scope, conversation_group_data, FirebaseService, $timeout, $dialog, LiveGroupData, conversations) ->
    console.log "In conversation state controller at bottom"
    $scope.conversation = conversation_group_data
    $scope.conversations = conversations
    $scope.$root.timestamp = conversation_group_data.current_timestamp

    $scope.name = 'ceConversationGroup'

    $scope.preview_template = "<%= path_to_asset "live/group-vote-insert.html" %>"

    $timeout ->
      $scope.conversation.filter_mode = 'table'
      $scope.conversation.filter_id = Number($scope.$root.user.last_name)
      $scope.refilter_table_comments()
      #$scope.$root.$broadcast 'calculate-tag-counts'
    , 500

    $scope.refilter_table_comments = () ->
      mode = $scope.conversation.filter_mode
      id = $scope.conversation.filter_id
      console.log "refilter_table_comments mode: #{mode}, id: #{id}"
      switch
        when mode is 'all'
          $scope.conversation.filtered_comments = $scope.conversation.table_comments

        when mode is 'untagged'
          $scope.conversation.filtered_comments = (comment for comment in $scope.conversation.table_comments when comment.tag_bools && comment.tag_bools[0] && comment.status != 'parked' )

        when mode is 'parked'
          $scope.conversation.filtered_comments = (comment for comment in $scope.conversation.table_comments when comment.status == 'parked')

        when mode is 'themes'
          $scope.conversation.filtered_comments = $scope.conversation.theme_comments.sort((a,b)-> a.order_id - b.order_id)

        when mode is 'theme'
          $scope.conversation.current_theme = _.findWhere($scope.conversation.theme_comments, {id: id})
          $scope.conversation.filtered_comments = []
          for id in $scope.conversation.current_theme.ordered_child_ids
            for comment in $scope.conversation.table_comments
              if comment.id is id
                $scope.conversation.filtered_comments.push comment
                break;

        when mode is 'table'
          $scope.conversation.filtered_comments = ( comment for comment in $scope.conversation.table_comments when Number(comment.table_number) is id)

    $scope.$on 'TableComment_update', (event, data) ->
      [original_rec, updated_rec] = FirebaseService.process_update($scope.conversation.table_comments, data)
      if updated_rec && original_rec
        updated_rec.editable_by_user = original_rec.editable_by_user || updated_rec.editable_by_user
      if data.action is 'save'
        $scope.refilter_table_comments()
]
live_choice_controller = [ "$scope", "conversations_and_themes", "LiveChooseData", "$timeout", "$dialog",
  ($scope, conversations_and_themes, LiveChooseData, $timeout, $dialog) ->
    $scope.question_1_themes = conversations_and_themes[0].theme_comments
    $scope.question_2_themes = conversations_and_themes[1].theme_comments
    $scope.question_3_themes = conversations_and_themes[2].theme_comments

    $scope.name = 'live_choice_controller'
    $scope.completed = false
    $scope.data = {}
    $scope.voter_id = 1
    $scope.member_votes = {}

    $scope.note_choice = ->
      choice = event.toElement.text
      id = event.toElement.id
      #console.log "note_choice: #{choice}, event.toElement: #{event.toElement.nodeName} with id: #{id}"
      li = angular.element(event.toElement).parent()
      if li.hasClass('disabled')
        event.stopPropagation()
        return
      li.parent().children().removeClass('active')
      li.addClass('active')
      par_button = li.parent().parent().find('button')
      #console.log "par_button.box: #{par_button.attr('box')}"
      par_button.attr('id', id )
      par_button.find('span').html(choice)
      # find the other A with the same id and set its LI to disabled
      a_links = angular.element( document.getElementById('live-choose')).find('a')
      for x, index in a_links
        a = a_links.eq(index)
        if a.attr('id') == id
          li = a.parent()
          if !li.hasClass('active')
            li.parent().find('li').removeClass('disabled')
            li.addClass('disabled')


      check_completed()

    check_completed = ->
      data = {}
      completed = true
      btns = angular.element( document.getElementById('live-choose')).find('button')
      for b, index in btns
        #buttom = angular.element(btn)
        button = btns.eq(index)
        box = button.attr('box')
        if box
          id = button.attr('id')
          data[box] = id
          #console.log "box: #{box} has id: #{id}"
      for key of data
        if typeof data[key] == 'undefined' || data[key] == null
          completed = false
        #console.log "key: #{key}: #{data[key]}"
      $scope.completed = completed
      $scope.data = data
      #console.log "$scope.completed: #{$scope.completed}"

    $scope.save = ->
      if $scope.completed
        console.log "save now"
        #for key of $scope.data
        #  console.log "'#{key}': #{$scope.data[key]}"
        LiveChooseData.record_choices($scope.data, $scope.voter_id).then(
          (response)->
            $scope.member_votes[$scope.voter_id] = response.data
            $scope.voter_id += 1
            page_top = angular.element( document.getElementById('live-choose'))
            page_top.find('button').find('span').removeAttr('id').html('Select choice')
            page_top.find('li').removeClass('active').removeClass('disabled')
            data = {}
            $scope.completed = false
        )

      else
        console.log "complete the form first"
]
live_allocate_controller = [ "$scope", "allocation_themes", "LiveAllocateData", "code", "$dialog",
  ($scope, allocation_themes, LiveAllocateData, code, $dialog) ->
    $scope.allocation_themes = allocation_themes

    $scope.name = 'live_allocate_controller'
    $scope.code = code

    $scope.over100 = false

    $scope.total = ->
      tot = 0
      for a in $scope.allocation_themes
        num = a.value
        if !isNaN(num)
          num = Number(a.value)
          if num > 50
            num = 50
            a.value = 50
          tot += num
      if tot > 100
        $scope.over100 = true
      else
        $scope.over100 = false

      tot

    $scope.save = ->
      console.log "Save the allocation"
      data = ( {id: at.id, points: at.value} for at in $scope.allocation_themes)

      LiveAllocateData.record_allocation($scope.code, data).then(
        (response)->
          btns = [{result:'ok', label: 'OK', cssClass: 'btn-primary'}]
          $dialog.messageBox('Thanks', "Your group's allocation has been recorded", btns).open()
      )

]