# Place all the behaviors and hooks related to the matching controller here.
# All this logic will automatically be available in application.js.
# You can use CoffeeScript in this file: http://jashkenas.github.com/coffee-script/

bootstrap_CE2 = ->
	#console.log "In bootstrap_CE2"

  if typeof Firebase == 'undefined'
    setTimeout bootstrap_CE2, 50
  else
    try
      angular.bootstrap(document,["CE2"])
    catch error
      setTimeout bootstrap_CE2, 50

bootstrap_CE2()


ce2_app = angular.module("CE2", ["ngResource","CE2.services", 'CE2.directives', 'CE2.filters',
  'ui.compat', 'ui.bootstrap'] )

ce2_app.config ($httpProvider) ->
	$httpProvider.defaults.headers.common["X-CSRF-TOKEN"] =
		document.querySelectorAll('meta[name="csrf-token"]')[0].getAttribute('content')


ce2_app.factory 'errorHttpInterceptor', ($q, $injector) ->
  (promise) ->
    promise.then (response) ->
      # do something on success
      #console.log "$httpProvider.responseInterceptors Success"
      promise # pass the promise on to the calling function
    , (response) ->
      # do something on error
      if (canRecover(response))
        return promise # let the response promise continue and be dealt with
      $dialog = $dialog || $injector.get("$dialog")
      switch response.data.class
        when "CanCan::AccessDenied"
          title = 'Access denied'
          msg = "Sorry, you are not authorized for this action [URL: #{response.config.url}, Controller: #{response.data.controller}, Action: #{response.data.action}]"
        else
          title = 'Server error'
          msg = "#{response.data.error} [URL: #{response.config.url}, Controller: #{response.data.controller}, Action: #{response.data.action}]"
      btns = [{result:'ok', label: 'OK', cssClass: 'btn-primary'}]
      $dialog.messageBox(title, msg, btns).open()
      #console.log "XXX $httpProvider.responseInterceptors Error\n#{response.data.error}"
      return $q.reject(response)
canRecover = (response) ->
  #if response.data.class?.match(/CanCan/)
  #  return false
  switch
    when response.config.url.match(/guest_posts/) && response.data.class is "ActiveRecord::RecordNotFound" then true
    when response.data.class then false
    when response.data.errors then true
    else false



ce2_app.config ($httpProvider) ->
  $httpProvider.responseInterceptors.push('errorHttpInterceptor')

ce2_app.value('Firebase', Firebase);

ce2_app.config ( [ '$stateProvider', '$urlRouterProvider',
  ($stateProvider, $urlRouterProvider) ->

    $urlRouterProvider
      # provides redirects
      .when('/c?id', '/contacts/:id')
      .otherwise('/home');

    $stateProvider
      # registers the urls with $urlRouterProvider
      .state('home', {
        url: '/home',
        templateUrl: '<%= path_to_asset "home.html" %>'
        resolve:
          conversations: ["ConversationData", (ConversationData) ->
            ConversationData.conversations()
          ]
        controller: [ "$scope", "conversations", "ConversationData", "$state",
          ($scope, conversations, ConversationData, $state) ->
            #console.log "In home state controller"
            $scope.conversations = conversations
            $scope.create_conversation = ->
              #console.log "create a new conversation and nav to it or show error"
              ConversationData.create_new_conversation().then (response) ->
                #console.log "RoR response to ConversationData.create_new_conversation with code: #{response.data.code}"
                $state.transitionTo('conversation', {code: response.data.code, munged_title: "new"})
        ]
      })

      .state( 'conversation',
        url: "/conversation/{code}/{munged_title}"
        #url: "/conversation/{code}/{munged_title:[^/]*}{path:.*}"
        templateUrl: '<%= path_to_asset "conversation.html" %>'
        resolve:
          conversation: ["ConversationData", "$stateParams", (ConversationData, $stateParams) ->
            console.log "resolve get ConversationData.conversation"
            ConversationData.conversation($stateParams.code)
            #console.log "conversation state with path: #{$stateParams.path}"
          ]
        onEnter: ($rootScope) ->
          $rootScope.initialize_markdown_system()
        controller: conversation_controller
      )

      .state('about', {
        url: '/about',
        templateProvider:
          [        '$timeout', ($timeout) ->
            $timeout ->
              "Hello <i>world</i>"
            , 100
          ]
      })

      .state('edit-profile', {
        url: '/edit-profile'
        templateUrl: '<%= path_to_asset "edit-profile.html" %>'
      })

      .state('test-autogrow', {
        url: '/test-autogrow'
        templateUrl: '<%= path_to_asset "test/autogrow.html" %>'
        controller: [ "$scope", ($scope) ->
          console.log "controller for test-autogrow"
          $scope.autoGrow = (oField) ->
            if oField.scrollHeight > oField.clientHeight
              oField.style.height = oField.scrollHeight + "px"
        ]
      })

      .state('test-animation', {
        url: '/test-animation'
        templateUrl: '<%= path_to_asset "test/animation.html" %>'
        controller: [ "$scope", ($scope) ->
          console.log "controller for test-animation"
          $scope.adjust = ->
            console.log "test-animation:adjust"
            $scope.step = not $scope.step
        ]
      })

      .state('test-sortable', {
        url: '/test-sortable'
        templateUrl: "<%= path_to_asset "test/sortable.html" %>"
        controller: [ "$scope", ($scope) ->
          #console.log "controller for test-sortable"
          $scope.items = [
            {id: 1, order_id: 1, text: 'item 1'},
            {id: 2, order_id: 2, text: 'item 2'},
            {id: 3, order_id: 3, text: 'item 3'},
            {id: 4, order_id: 4, text: 'item 4'},
            {id: 5, order_id: 5, text: 'item 5'}
          ]
          $scope.test = ->
            console.log "test in sortable"
        ]
      })

])

ce2_app.run( ['$rootScope', '$state', '$stateParams', "$timeout", "TemplateEngine", "$http", "$templateCache", "$dialog", "$location",
  ($rootScope,   $state,   $stateParams, $timeout, TemplateEngine, $http, $templateCache, $dialog, $location) ->
    $rootScope.dev_mode = if $location.host().match(/dev$/) then true else false
    $rootScope.$state = $state
    $rootScope.$stateParams = $stateParams
    $rootScope.CSRF = document.querySelectorAll('meta[name="csrf-token"]')[0].getAttribute('content')

    $rootScope.$on '$stateChangeError', (event, toState, toParams, fromState, fromParams, error) ->
      console.log "$stateChangeError tostate: #{toState.url}, fromState: #{fromState.url}"
    $rootScope.$on '$stateChangeStart', (event, toState, toParams, fromState, fromParams) ->
      console.log "$stateChangeStart tostate: #{toState.url}, fromState: #{fromState.url}"
    $rootScope.$on '$stateChangeSuccess', (event, toState, toParams, fromState, fromParams) ->
      console.log "$stateChangeSuccess tostate: #{toState.url}, fromState: #{fromState.url}"

    $rootScope.$on '$viewContentLoaded', (obj) ->
      console.log "$viewContentLoaded"

    $rootScope.autoGrow = (oField) ->
      if oField.scrollHeight > oField.clientHeight
        oField.style.height = oField.scrollHeight + "px"

    $rootScope.text_select_by_mouse = ->
      debug_mode = false
      console.log "text_select_by_mouse" if debug_mode
      try
        [text, comment, coords] = capture_selection()
        if text
          #console.log "use this string in form:\n#{text}" if debug_mode
          $rootScope.selection =
            text: text
            id: comment.id
            purpose: comment.purpose
            name: "#{comment.first_name} #{comment.last_name}"
            version: comment.version
            photo: comment.photo_code

          body = document.documentElement || document.body
          scrollX = window.pageXOffset || body.scrollLeft
          scrollY = window.pageYOffset || body.scrollTop
          $rootScope.show_add_quote_to_reply_style =
            display: 'block'
            position: 'absolute'
            top: "#{coords.top + scrollY}px"
            left: "#{coords.left + scrollX}px"

          $timeout ->
            angular.element(document).bind('mouseup', clear_capture_selection_button)
          ,100

        else
          $rootScope.show_add_quote_to_reply_style =
            display: "none"

        $rootScope.$$phase || $rootScope.$apply()

      catch error
        console.log "$rootScope.text_select_by_mouse had an error: #{error}" if debug_mode

    $rootScope.add_quote_to_reply = ->
      sel = $rootScope.selection
      quote_insert = "[quote=#{sel.name}~#{sel.purpose}~#{sel.id}~#{sel.photo}~#{sel.version}]#{sel.text}[/quote]"
      #console.log "Add this quote to textarea: #{quote_insert}"
      $rootScope.$broadcast('conversation-comment-edit')
      textarea = document.getElementById('reply-control').getElementsByTagName('textarea')[0]
      textarea.value += "\n" + quote_insert
      $rootScope.show_add_quote_to_reply_style =
        display: "none"
      $rootScope.$$phase || $rootScope.$apply()
      newComment = angular.element(textarea).scope().newComment
      newComment.text = textarea.value

    $rootScope.initialize_markdown_system = ->
      #console.log "initialize_markdown_system"
      # which will call initialize_markdown_editor
      initialize_markdown_converter( TemplateEngine, $timeout, $dialog, $rootScope )

    $http.get("<%= path_to_asset "quote.html" %>", {cache:$templateCache};)

])

capture_selection = ->
  debug_mode = false
  console.log "capture_selection" if debug_mode
  if document.all
    # get the selection for IE
    sel = document.selection
    range = sel.createRange()
    # IE's selection gives the text with linefeeds automatically
    str = range.text
    console.log "use this string in form:\n#{str}"  if debug_mode
    # get a node in the selection so I can find the parent comment
    node = range.parentElement()

    range.collapse(true);
    coords =
      left: range.boundingLeft
      top:  range.boundingTop;

  else
    # get the selection for other browsers
    sel = document.getSelection()
    # the text from the selection doesn't respect linefeeds, so I must manually respect linefeeds
    console.log "conversation_select text: #{sel.toString() }" if debug_mode
    # turn the selection into a range
    range = sel.getRangeAt(0)
    # now get the string while respecting the linefeeds
    frag = range.cloneContents()
    child_nodes = frag.childNodes
    # get the text for each of the nodes, without formatting
    #strs = ( (if node.innerHTML then node.innerHTML else node.textContent).replace(/^\s*/,'').replace(/\s*$/,'') for node in child_nodes)
    strs = ( (node.textContent).replace(/^\s*/,'').replace(/\s*$/,'') for node in child_nodes)

    str = strs.join('\n\n').replace(/<br[^>]*>/ig, '\n')

    # get a node of the range in the selection so I can find the parent comment
    node = range.startContainer

    # get the selection coordinates
    range = range.cloneRange()
    range.collapse(true);
    coords = range.getClientRects()[0];
    console.log "coords top: #{coords.top}, left: #{coords.left}" if debug_mode

  if str
    str = str.replace(/^ */gm, '').replace(/\r\n/g, '\n').replace(/\n{2,}/g,'\n\n')
    [str, angular.element(node).scope().comment, coords]
  else
    [null,null,null]

clear_capture_selection_button = ->
  #console.log "clear_capture_selection_button mouseup, then clear"
  doc = angular.element(document)

  rootScope = doc.scope().$root
  rootScope.show_add_quote_to_reply_style =
    display: "none"
  rootScope.$$phase || rootScope.$apply()

  doc.unbind('mouseup', clear_capture_selection_button)

initialize_markdown_converter = (TemplateEngine, $timeout, $dialog, $rootScope) ->
  opts = { TemplateEngine: TemplateEngine } # unless opts
  quoteTemplate = null

  #converter = new Markdown.getSanitizingConverter()
  # Since I am using hooks, I will manually hook in sanitize at the end
  converter = new Markdown.Converter();
  editor = new Markdown.Editor converter

  # Before cooking callbacks
  converter.hooks.chain "preConversion", (text) ->
    #Discourse.Markdown.trigger('beforeCook', { detail: text, opts: opts });
    #return Discourse.Markdown.textResult || text;
    return text

  # Extract quotes so their contents are not passed through markdown.
  converter.hooks.chain "preConversion", (text) ->
    extracted = Markdown.BBCode.extractQuotes(text)
    quoteTemplate = extracted.template;
    return extracted.text;

  converter.hooks.chain "postConversion", (text) ->
    # reapply quotes
    text = quoteTemplate(text) if quoteTemplate
    return Markdown.BBCode.format(text, opts);

  Markdown.upload_dialog = (linkEnteredCallback) ->
    console.log "call the upload dialog"

    dialog = $dialog.dialog(
      backdrop: true
      keyboard: true
      backdropClick: true
      templateUrl: '<%= path_to_asset "insert-image-form.html" %>'
      controller: ["$scope", "$timeout", ($scope, $timeout) ->
        debug = false
        $scope.type = 'local'
        $scope.image = {conversation_code: angular.element(document.getElementById('wmd-input')).scope().conversation.code }

        console.log "in dialog, $scope.image.conversation_id: #{$scope.image.conversation_id} "

        $scope.show_tab = (str) ->
          if str is 'web'
            console.log "show web tab"
            $scope.type = 'web'
          else
            console.log "show local tab"
            $scope.type = 'local'
        $scope.submit = ->
          console.log "submit url: #{$scope.image.url}"
          linkEnteredCallback($scope.image.url)
          dialog.close()

        $scope.upload = ->
          console.log "upload file"
          file_input = document.getElementById('filename-input')
          if file_input.files.length > 0
            file_name = file_input.files[0].name
            console.log "loading file: #{file_name}" if debug
            $scope.progress_bar_message = "<i class='icon-spinner icon-spin'></i><span>Loading #{file_name}</span>"
            image_upload_form.submit()

        $scope.iframe_loaded = (el) ->
          # have access to $scope here
          console.log "ceCommentForm: window.iframe_loaded, get the contents" if debug

          content = el.contentDocument.body.innerText
          if content
            attachment = angular.fromJson(content)
            console.log "in_page_url is #{attachment.in_page_url}"
            $timeout ->
              linkEnteredCallback(attachment.in_page_url, {width: attachment.image_width, height: attachment.image_height});
              dialog.close()
              $scope.$root.$broadcast('update-new-comment-text')

        $scope.cancel = ->
          dialog.close()
      ]
    )
    dialog.open()
    $rootScope.$$phase || $rootScope.$apply()
  $timeout ->
    initialize_markdown_editor(editor)
  , 1000
  $rootScope.converter = converter
  $rootScope.editor = editor


initialize_markdown_editor = (editor, editor_id = 'wmd-input', init_ctr = 5) ->
  #console.log "initialize_markdown_editor with editor_id: #{editor_id} and init_ctr: #{init_ctr}"
  edit_input = document.getElementById(editor_id)
  if edit_input && editor && editor.run
    #console.log "init_editor now"
    editor.run()
  else if (init_ctr -= 1 ) > 0
    #console.log "try to init editor in 1 sec"
    $timeout ->
      initialize_markdown_editor(editor, editor_id, init_ctr )
    , 1000

conversation_controller = [ "$scope", "conversation", "FirebaseService", "$timeout", "ConversationData", "$dialog",
  ($scope, conversation, FirebaseService, $timeout, ConversationData, $dialog) ->
    console.log "In conversation state controller at bottom"
    $scope.conversation = conversation
    $scope.$root.timestamp = conversation.current_timestamp
    $scope.newComment = { }

    $scope.name = 'ceConversation'
    # the data was resolved and attached to scope in the state definition
    
    $timeout ->
      if $scope.conversation.role == 'conversation_admin' && !$scope.conversation.published
        $scope.conversation_wizard_mode = true

      if $scope.conversation.can('show_participants')
        ConversationData.load_stats($scope.conversation.code).then(
          (response)->
            for key of response.data
              $scope.conversation[key] = response.data[key]
          )
    , 1000

    $scope.show_comment_form = (type, in_reply_to_id = null, in_reply_to_version = null) ->
      if conversation.privacy.unknown_users=='false' && !conversation.can('post_prescreen')
        title = 'Sorry'
        msg = "Only invited conversation participants are allowed to post comments"
        btns = [{result:'ok', label: 'OK', cssClass: 'btn-primary'}]
        $dialog.messageBox(title, msg, btns).open()
        return

      console.log "show_comment_form type: #{type}, in_reply_to_id: #{in_reply_to_id}"
      # clear new comment
      for key of $scope.newComment
        delete $scope.newComment[key] unless key=='email' || key =='first_name' || key =='last_name'
      $scope.newComment.conversation_code = $scope.conversation.code
      if type == 'summary'
        console.log "#### Set the type for summary"
        $scope.newComment.type = 'SummaryComment'
        $scope.reply_control_title = "Add summary comment"
      else if type == 'conversation'
        #console.log "Set the type for conversation"
        $scope.newComment.type = 'ConversationComment'
        $scope.reply_control_title = "Add conversation comment"
      else if type == 'conversation-reply'
        console.log "Set the type for converation-reply"
        $scope.newComment.type = 'ConversationComment'
        $scope.reply_control_title = "Reply to conversation comment"
        $scope.newComment.in_reply_to_id = in_reply_to_id
        $scope.newComment.in_reply_to_version = in_reply_to_version
      else if type == 'summary-reply'
        console.log "Set the type for summary-reply"
        $scope.newComment.type = 'ConversationComment'
        $scope.reply_control_title = "Reply to summary comment"
        $scope.newComment.in_reply_to_id = in_reply_to_id
        $scope.newComment.in_reply_to_version = in_reply_to_version
      else if type == 'call-to-action-reply'
        console.log "Set the type for cta-reply"
        $scope.newComment.type = 'ConversationComment'
        $scope.reply_control_title = "Reply to call-to-action"
        $scope.newComment.in_reply_to_id = in_reply_to_id
        $scope.newComment.in_reply_to_version = in_reply_to_version

      $timeout -> $scope.$root.editor.refreshPreview()
      reply_control = angular.element( document.getElementById('reply-control'))
      reply_control.addClass('open show-preview')
      # determine if special class for non-participant, not signed in, not confirmed
      special_class = switch
        when $scope.$root.user == "null"
          $scope.newComment.join = true
          'unknown-user'
        when $scope.conversation.role == "none"
          $scope.newComment.join = true
          'non-participant-user'
        when $scope.$root.user.confirmed != true
          'non-confirmed-user'
      reply_control.addClass(special_class) if special_class
      $scope.$root.$broadcast "user-event-notification", { action: "open comment-form #{$scope.newComment.type}"}

    $scope.$on 'request-edit', (event, comment) ->
      $scope.newComment = {id: comment.id, text: comment.text, type: comment.type, purpose: comment.purpose}
      $scope.reply_control_title = switch $scope.newComment.type
        when 'ConversationComment' then "Edit conversation comment"
        when 'SummaryComment' then "Edit summary comment"
        when 'CallToActionComment'
          if $scope.newComment.id is 0
            $scope.newComment.id = null
            $scope.newComment.text = ''
            $scope.newComment.conversation_code = $scope.conversation.code
            $scope.$root.$broadcast "user-event-notification", { action: 'open call-to-action edit'}
            "Add your first call-to-action"
          else
            "Edit call-to-action"
      $timeout -> $scope.$root.editor.refreshPreview()
      angular.element( document.getElementById('reply-control')).addClass('open show-preview')

    $scope.$on 'clear-edit', (event) ->
      for key of $scope.newComment
        delete $scope.newComment[key] unless key=='email' || key =='first_name' || key =='last_name'
      $timeout -> $scope.$root.editor.refreshPreview()
      angular.element( document.getElementById('reply-control')).removeClass('open')

    $scope.$on 'conversation-comment-edit', (event) ->
      if angular.element( document.getElementById('reply-control')).hasClass('open')
        #console.log "Reply form is already open, don't alter newComment properties"
        return
      else  
        #console.log "Open and set reply form for conversation-comment-edit"
        $scope.newComment.type = 'ConversationComment'
        $scope.newComment.conversation_code = $scope.conversation.code
        $timeout -> $scope.$root.editor.refreshPreview()
        angular.element( document.getElementById('reply-control')).addClass('open')

    $scope.$on 'cancel-edit', (event) ->
      for key of $scope.newComment
        delete $scope.newComment[key] unless key=='email' || key =='first_name' || key =='last_name'
      $timeout -> $scope.$root.editor.refreshPreview()
      angular.element( document.getElementById('reply-control')).removeClass('open')

    $scope.$on 'toggle-compose-window', ->
      #console.log "toggle_compose_window"
      composer = angular.element( document.getElementById('reply-control') )
      if composer.hasClass('open')
        composer.removeClass('open show-preview')
        $scope.$root.editor.refreshPreview()
      else
        composer.addClass('open show-preview')

    # Subscribe to updates for this data
    url = "https://civicevolution.firebaseio.com/conversations/#{$scope.conversation.code}/updates/"
    #console.log "firebase url: #{url}"
    FirebaseService.initialize_source(url, $scope.conversation.firebase_token)

    # register the listeners for the firebase updates
    $scope.$on 'ConversationComment_update', (event, data) ->
      #console.log "received broadcast ConversationComment_update"
      [original_rec, updated_rec] = FirebaseService.process_update($scope.conversation.conversation_comments, data)
      if updated_rec && original_rec
        updated_rec.editable_by_user = original_rec.editable_by_user || updated_rec.editable_by_user
        if updated_rec.purpose isnt original_rec.purpose
          console.log "update the graph to show new labels"
          element = angular.element(document.getElementById("com-#{updated_rec.id}"))
          canvas = element.find('canvas')
          canvas.scope().redraw_rating_graph( element )

    $scope.$on 'SummaryComment_update', (event, data) ->
      #console.log "received broadcast SummaryComment_update"
      [original_rec, updated_rec] = FirebaseService.process_update($scope.conversation.summary_comments, data)
      if updated_rec && original_rec
        updated_rec.editable_by_user = original_rec.editable_by_user || updated_rec.editable_by_user

    $scope.$on 'RatingsCache_update', (event, data) ->
      #console.log "received broadcast RatingsCache_update"
      data = data.data
      item_array = switch data.type
        when "SummaryComment" then $scope.conversation.summary_comments
        when "ConversationComment" then $scope.conversation.conversation_comments
      if item_array
        for rec in item_array
          if rec.id == data.id
            comment = rec
            break
        if comment
          #console.log "Update the ratings on comment id: #{comment.id}"
          comment.number_of_votes = data.number_of_votes
          comment.ratings_cache = data.ratings_cache
          $scope.$$phase || $scope.$apply()


    $scope.$on 'CallToActionComment_update', (event, data) ->
      #console.log "received broadcast CallToActionComment_update"
      if not $scope.conversation.call_to_action_comment
        # is user the curator? must be as conversation cannot be pusblished without a cta
        $scope.conversation.call_to_action_comment = { editable_by_user: true }
      editable_by_user = $scope.conversation.call_to_action_comment.editable_by_user
      $scope.conversation.call_to_action_comment[prop] = data.data[prop] for prop of data.data when not prop.match(/^\$/)
      $scope.conversation.call_to_action_comment.editable_by_user = editable_by_user
      $scope.$$phase || $scope.$apply()

    $scope.ConversationCommentLength = 1500
    $scope.SummaryCommentLength = 0

    # register a listener for summary_comments ordered ids
    $scope.$on 'Conversation_update', (event, data) ->
      #console.log "received broadcast Conversation_update"

      # make sure it is the correct conversation_id
      # $scope.conversation.id
      if Number(data.data.conversation_id) is Number($scope.conversation.id)
        ordered_ids = data.data.ordered_ids
        # reorder $scope.conversation.summary_comments according to these ids
        if ordered_ids
          # update the order_id for the comments
          for comment in $scope.conversation.summary_comments
            comment.order_id = ordered_ids[comment.id]
          #resort the summary_comments according to order_id
          $scope.conversation.summary_comments.sort((a, b) -> return a.order_id > b.order_id )
        $scope.$$phase || $scope.$apply()

    $scope.edit_title = ->
      #console.log "edit the title"
      $scope.title_temp = $scope.conversation.title
      $scope.conversation.edit_title = true
      $scope.$root.$broadcast "user-event-notification", { action: 'open title edit'}

    $scope.save_title = ->
      ConversationData.save_title($scope.conversation.code, $scope.conversation.title).then (response) ->
        #console.log "return from save_title"
        $scope.conversation.title = response.data.text
        $scope.conversation.edit_title = false
        $scope.$root.$broadcast "user-event-notification", { action: 'save title edit'}

    $scope.cancel_title_edit = ->
      $scope.conversation.title = $scope.title_temp
      $scope.conversation.edit_title = false

    $scope.$on 'Publish conversation', (event, data) ->
      console.log "publishConversation with code: #{data.conversation_code}"
      $scope.form_submit_status = '<i class="icon-spinner.icon-spin">Publishing</i>'
      ConversationData.publish_conversation(data.conversation_code).then (response)->
        #console.log "ConversationData.publish_conversation received response"
        $scope.form_submit_status = 'Published'
        $timeout ->
          $scope.form_submit_status = 'Publish'
          $scope.$root.$broadcast "user-event-notification", { action: 'conversation published'}
        ,800


]
