#console.log("loading services.js.coffee");

services = angular.module("CE2.services", ["ngResource"])

services.factory 'User', [ "$http", "$window", ($http, $window) ->
  # a static method to retrieve current User
  name: "User"
  get: ->
    $http.get('/api/users/user.json').then (response) ->
      response.data

  sign_in: (user) ->
    #console.log "User.sign_in  with data: #{user.email}/#{user.password}"
    $http.post('/users/sign_in.json', {user: user })

  sign_out: ->
    #console.log "User:sign_out"
    $http({method: 'DELETE', url: '/users/sign_out.json'})

  sign_up: (user) ->
    #console.log "User.sign_up with credentials: #{user.name}/#{user.email}/#{user.password}"
    $http.post('/users.json', {user: user })

  forgot_password: (user) ->
    #console.log "User.sign_up with credentials: #{user.name}/#{user.email}/#{user.password}"
    $http.post('/users/password.json', {user: user })

  request_confirmation: (user) ->
    #console.log "User.request_confirmation with credentials: #{user.email}"
    $http.post('/users/confirmation.json', {user: user })

  change_password: (user) ->
    #console.log "User.change_password with credentials: cp: #{user.current_password} np: #{user.password} pc: #{user.password_confirmation}"
    $http.put('/users.json', {user: user })

  edit_profile: ->
    console.log 'User:edit_profile'

]

services.factory 'NotificationRequest', [ "$http", ($http) ->
  # a static method to retrieve current User
  name: "NotificationRequest"
  save_settings: (conversation_code, settings) ->
    $http.post("/api/notification_requests.json", {conversation_code: conversation_code, settings: settings})

]

services.factory "Comment", ["$resource", ($resource) ->
  $resource("/api/comments/:id", {id: "@id"}, {update: {method: "PUT"}})
]

services.factory "ConversationData", ["$http",
  ($http) ->
    name: "ConversationData"

    conversations: ->
      $http.get("/api/conversations.json").then (response) ->
        #console.log "/api/conversations.json then"
        #if response.status is 200
        response.data

    save_title: (conversation_code, title) ->
      console.log "save_title to RoR code: #{conversation_code} with title #{title}"
      $http.post("/api/conversations/#{conversation_code}/title.json", {title: title})

    conversation: (conversation_code) ->
      # conversation(conversation_code) is called by the directive or controller that uses this data
      # this request returns a promise to the directive
      # a promise is also resolved in this original call
      # the promise segragates the data and sorts it into order
      # the then() call in the directive assigns the data components to this service
      # as well as assigning it to $scope
      # and subscribing to Firebase updates on this data
      # The updates are broadcast and controllers can update their scope data
      # see description below with FirebaseService

      $http.get("/api/conversations/#{conversation_code}.json").then (response) ->
        if response.status is 200
          summary_comments = []
          conversation_comments = []
          for comment in response.data.comments
            switch comment.type
              when "SummaryComment" then summary_comments.push comment
              when "ConversationComment" then conversation_comments.push comment
              when "TitleComment" then title_comment = comment
              when "CallToActionComment" then call_to_action_comment = comment

          for comment in conversation_comments
            comment.quote_expanded = "false"
            if comment.id is 23
              comment.reply_ids = [33,34]
            else
              comment.reply_ids = []
            if comment.id is 33
              comment.in_reply = { id: 23, name: 'Brian Sullivan'}
            else
              comment.in_reply = null
          #console.log "conversation_id: #{conversation_id}"
          # extract and setup some data for the directive controller
          firebase_token: response.data.firebase_token
          summary_comments: summary_comments.sort((a,b)-> a.order_id - b.order_id)
          conversation_comments: conversation_comments.sort((a,b)-> a.order_id - b.order_id)
          title_comment: title_comment
          call_to_action_comment: call_to_action_comment || {
            editable_by_user: true
            id: 0
            purpose: "Call to action"
            text: "This area is for your call-to-action. Here you describe this conversation and suggest ways for people to contribute."
            type: "CallToActionComment"
            updated_at: new Date()
            version: 0
          }
          title: response.data.title
          code: response.data.code
          current_timestamp: response.data.current_timestamp
          privacy: response.data.privacy
          tags: response.data.tags.sort()
          starts_at: new Date(response.data.starts_at)
          ends_at: new Date(response.data.ends_at)
          published: response.data.published
          list: response.data.list
          status: response.data.status
          notification_request  : response.data.notification_request

    persist_summary_comment_order_to_ror: (conversation_code, comments_order) ->
      #console.log "persist_summary_comment_order_to_ror send order to RoR id: #{conversation_code} with order #{comments_order}"
      $http.post("/api/conversations/#{conversation_code}/summary_comment_order.json", {ordered_ids: comments_order})

    persist_privacy_to_ror: (conversation_code, privacy) ->
      $http.post("/api/conversations/#{conversation_code}/privacy.json", {privacy: privacy})

    persist_tags_to_ror: (conversation_code, tags) ->
      $http.post("/api/conversations/#{conversation_code}/tags.json", {tags: tags})

    persist_schedule_to_ror: (conversation_code, starts_at, ends_at) ->
      $http.post("/api/conversations/#{conversation_code}/schedule.json", {start: starts_at, end: ends_at})

    create_new_conversation: ->
      $http.post("/api/conversations.json")

    publish_conversation: (conversation_code) ->
      $http.post("/api/conversations/#{conversation_code}/publish.json")

]

services.factory "CommentData", ["$log", "$http", "Comment", "$rootScope",
  ($log, $http, Comment, $rootScope) ->
    name: "CommentData"

    history: (comment_id) ->
      console.log "Retrieve history for comment #{comment_id}"
      $http.get("/api/comments/#{comment_id}/history").then (response) ->
        response.data

    persist_change_to_ror: (action, data, ok_cb, err_cb) ->
        _this._ok_cb = ok_cb
        _this._err_cb = err_cb
        action = 'update' if data.id
        Comment[action] data, (data,resp_headers_fn) =>
          _this._ok_cb() if _this._ok_cb
          # broadcast this new item available that needs an update
          #console.log "broadcast this update"
          $rootScope.$broadcast "#{data.type}_update", {
            action: action
            class: data.type
            data: data
            updated_at: data.updated_at
            source: "#{action}Comment"
          }
        , err_func

    create_in_ror: (action, data, ok_cb, err_cb) ->
      _this._ok_cb = ok_cb
      _this._err_cb = err_cb
      if data.id
        action = 'update'
        method = 'put'
        url = "/api/comments/#{data.id}.json"
      else
        method = 'post'
        url = "/api/conversations/#{data.conversation_code}/comments.json"
      #console.log "method: #{method}, url: #{url}"
      $http[method](url, data).then (response) =>
        _this._ok_cb() if _this._ok_cb
        $rootScope.$broadcast "#{response.data.type}_update", {
          action: action
          class: response.data.type
          data: response.data
          updated_at: response.data.updated_at
          source: "#{action}Comment"
        }

    persist_rating_to_ror: (comment_id, rating) ->
      #console.log "send rating to RoR id: #{comment_id} with rating #{rating}"
      $http.post("/comments/#{comment_id}/rate/#{rating}.json")

    get_comment: (id) ->
      $http.get("/api/comments/#{id}")

    get_comments: (ids) ->
      $http.get("/api/comments?ids=#{ids.join(',')}")

]

# The controllers are responsible for requesting their data and storing it to scope
# The data is requested from a service
# In the callback, the controllers assigns the data to a scope object
# The models are updated from internal posts and external updates the same way
# e.g. when a comment is posted to the server it is also displayed locally by
# by broadcasting an update
# The controllers registers listeners for events that relate to their scope data
# When the controller receives an event notification about its scope data, it updates its collection
# using FirebaseService.process_update(item_array, data)
# Updates from firebase are also added to the bound data
# When child_added is detected, the event is broadcast with the data
# again, the controller listens for the event and then calls FirebaseService.process_update(item_array, data)
# These updates are generated by RoR posting the update to firebase which then
# delivers it to the subscribed clients
# My local post will be processed into the model data twice, once after posting to RoR
# and a second time when RoR sends update to Firebase which sends update to all subscribers
# The updates are idempotent, so multiple updates don't matter

services.factory "FirebaseService", [ "$timeout", "$rootScope", ($timeout, $rootScope ) ->
  name: "FirebaseService"
  initialize_source: (url, token) ->
    #console.log "Firebase.initialize_source a new Firebase Update Source with"
    #console.log "firebase url: #{url}"
    #console.log "firebase token: #{token}"
    conversation_updates_ref = new Firebase(url);
    conversation_updates_ref.auth( token )
    conversation_updates_ref.on 'child_added', (data) ->
      data = data.val()
      #console.log "Firebase $broadcast #{data.val().class}_update"
      update_all = false
      if update_all || (Date.fromISO(data.updated_at).getTime() / 1000 ) - $rootScope.timestamp > 0
        $rootScope.$broadcast( "#{data.class}_update", data )
      #else
      #  console.log "Ignore this old update"

  process_update: (item_array, data) ->
    console.log "Firebase.process_update for #{data.class}"
    # Only apply updates newer than the page load time
    update_all = false
    if update_all || (Date.fromISO(data.updated_at).getTime() / 1000 ) - $rootScope.timestamp > 0
      if data.action == "delete"
        for rec, index in item_array
          if rec.id == data.data.id
            return item_array.splice(index, 1)
      else
        new_rec = data.data
        #console.log "looking at data with id: #{new_rec.id} and text: #{new_rec.text}"
        for rec, index in item_array
          if rec.id == new_rec.id
            original_rec = angular.copy(item_array[index])
            updated_rec = item_array[index]
            item_array[index][prop] = new_rec[prop] for prop of new_rec when not prop.match(/^\$/)
            new_rec = null
            break
        if new_rec
          new_obj = {}
          new_obj[prop] = new_rec[prop] for prop of new_rec when not prop.match(/^\$/)
          item_array.push new_obj
      $rootScope.$$phase || $rootScope.$apply();
    [original_rec, updated_rec]
]

services.factory "TemplateEngine",
  ($rootScope, $templateCache, $http, $interpolate) ->
    name: "TemplateEngine"
    interpolation_fns: {}

    interpolate: (templateName, args) ->
      #console.log "TemplateEngine.compile with templateName: #{templateName}"

      # get the interplotion function from a cache
      interpolate_fn = this.interpolation_fns[templateName]

      if interpolate_fn
        # use the cached interpolation function to convert the quote data into html
        return interpolate_fn(args)

      else
        # if not existing, get the template and create the function and store in cache
        #template = $templateCache.get("/assets/angular-views/#{templateName}.html")
        template = $templateCache.get("<%= path_to_asset "quote.html" %>")

        if template
          interpolate_fn = $interpolate(template[1])
          this.interpolation_fns[templateName] = interpolate_fn
          return interpolate_fn(args)

        else
          # I have to intentionally load the template in app.run() with
          # $http.get("/assets/angular-views/quote.html", {cache:$templateCache};)
          # my attempts to load the template when I realize I need cause problems
          # of deep iteration.
          # $broadcast/$on is tightly coupled leading to the same deep iteration
          #$rootScope.$broadcast('load_template',templateName)
          ## load the required template to cache and it will be used next time
          #console.log "load the template for #{templateName}"
          ##$http.get("/assets/angular-views/#{templateName}.html", {cache:$templateCache};)
          ##$http.get("/assets/angular-views/#{templateName}.html")
          return "Initializing TemplateEngine for #{templateName}"




###
  ok_func(data,resp_headers_fn) 
    data is the returned data
    resp_headers_fn('Server') (e.g.)
      "thin 1.5.1 codename Straight Razor"
###

ok_func = (data,resp_headers_fn) ->
  console.log("ok_func");    
  temp.data = data;


###
  err_func(error_object)
    error_object.config.data  (The data that was sent, e.g.)
      Resource {created_at: "2013-04-11T07:05:12Z", id: 18, liked: false, name: "Charley", text: "check it out"…}

    error_object.config.method: "PUT"
    error_object.config.url: "/comments/18" (The URL that was called)

    error_object.headers() >> Response headers returned (e.g.)
      error_object.headers('Server')
        "thin 1.5.1 codename Straight Razor"

    error_object.status
      500

    error_object.data (The error string that was returned e.g.)
      "ActiveRecord::RecordNotFound at /comments/18
      ============================================

      > Couldn't find Comment without an ID

      With full stack trace ...
###    

err_func = (error_object) ->
  reported_error = error_object.data
  key = ("#{name}" for name, msg of reported_error)[0]
  errors = reported_error[key]
  switch 
    when error_object.status is 504
      console.log "504 Gateway Time-out. The server didn't respond in time"

    else
      switch key
        when 'errors'
          error_message = ("Field: #{field}, Error: #{msg}" for field, msg of errors).join('\n')
          console.log error_message
        when 'system_error'
          console.log "System Error: #{errors}"
        else
          console.log "Don't know how to handle this error"
          #debugger
