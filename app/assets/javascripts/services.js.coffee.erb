#console.log("loading services.js.coffee");

services = angular.module("CE2.services", ["ngResource"])

services.factory 'User', [ "$http", "$window", ($http, $window) ->
  # a static method to retrieve current User
  name: "User"
  get: ->
    $http.get('/api/users/user.json').then (response) ->
      response.data

  sign_in: (user) ->
    #console.log "User.sign_in  with data: #{user.email}/#{user.password}"
    $http.post('/users/sign_in.json', {user: user })

  sign_out: ->
    #console.log "User:sign_out"
    $http({method: 'DELETE', url: '/users/sign_out.json'})

  sign_up: (user) ->
    #console.log "User.sign_up with credentials: #{user.name}/#{user.email}/#{user.password}"
    $http.post('/users.json', {user: user })

  forgot_password: (user) ->
    #console.log "User.sign_up with credentials: #{user.name}/#{user.email}/#{user.password}"
    $http.post('/users/password.json', {user: user })

  request_confirmation: (user) ->
    #console.log "User.request_confirmation with credentials: #{user.email}"
    $http.post('/users/confirmation.json', {user: user })

  change_password: (user) ->
    #console.log "User.change_password with credentials: cp: #{user.current_password} np: #{user.password} pc: #{user.password_confirmation}"
    $http.put('/users.json', {user: user })

  edit_profile: ->
    console.log 'User:edit_profile'

  send_contact_us_message: (message) ->
    #console.log "User.send_contact_us_message with message: #{message.text}"
    $http.post('/contact_us.json', {message: message })

  send_activity_report: (report) ->
    $http.post('/activity_report.json', {report: report })

  test: ->
    $http.get('/api/users/user.json')

]

services.factory 'NotificationRequest', [ "$http", ($http) ->
  # a static method to retrieve current User
  name: "NotificationRequest"
  save_settings: (conversation_code, settings) ->
    $http.post("/api/notification_requests.json", {conversation_code: conversation_code, settings: settings})

]

services.factory "Comment", ["$resource", ($resource) ->
  $resource("/api/comments/:id", {id: "@id"}, {update: {method: "PUT"}})
]

services.factory "ConversationData", ["$http",
  ($http) ->
    name: "ConversationData"

    conversations: ->
      $http.get("/api/conversations.json").then (response) ->
        #console.log "/api/conversations.json then"
        #if response.status is 200
        response.data

    save_title: (conversation_code, title) ->
      console.log "save_title to RoR code: #{conversation_code} with title #{title}"
      $http.post("/api/conversations/#{conversation_code}/title.json", {title: title})

    conversation: (conversation_code) ->
      # conversation(conversation_code) is called by the directive or controller that uses this data
      # this request returns a promise to the directive
      # a promise is also resolved in this original call
      # the promise segragates the data and sorts it into order
      # the then() call in the directive assigns the data components to this service
      # as well as assigning it to $scope
      # and subscribing to Firebase updates on this data
      # The updates are broadcast and controllers can update their scope data
      # see description below with FirebaseService

      $http.get("/api/conversations/#{conversation_code}.json").then (response) ->
        if response.status is 200
          summary_comments = []
          conversation_comments = []
          authors = {}
          for comment in response.data.displayed_comments
            switch comment.type
              when "SummaryComment" then summary_comments.push comment
              when "ConversationComment" then conversation_comments.push comment
              when "TitleComment" then title_comment = comment
              when "CallToActionComment" then call_to_action_comment = comment
            authors[comment.name] = comment.code
          authors = ( {name: name, photo_code: authors[name]} for name of authors when name != 'Unconfirmed_User')

          #console.log "conversation_id: #{conversation_id}"
          # extract and setup some data for the directive controller
          firebase_token: response.data.firebase_token
          summary_comments: summary_comments.sort((a,b)-> a.order_id - b.order_id)
          conversation_comments: conversation_comments.sort((a,b)-> a.order_id - b.order_id)
          title_comment: title_comment
          call_to_action_comment: call_to_action_comment || {
            editable_by_user: true
            id: 0
            purpose: "Call to action"
            text: "This area is for your call-to-action. Here you describe this conversation and suggest ways for people to contribute."
            type: "CallToActionComment"
            updated_at: new Date()
            version: 0
          }
          title: response.data.title
          code: response.data.code
          current_timestamp: response.data.current_timestamp
          privacy: response.data.privacy
          tags: response.data.tags.sort()
          starts_at: new Date(response.data.starts_at)
          ends_at: new Date(response.data.ends_at)
          published: response.data.published
          list: response.data.list
          status: response.data.status
          notification_request  : response.data.notification_request
          participants: authors
          role: response.data.role.name
          abilities: response.data.role.abilities
          can: (action) ->
            _.indexOf(this.abilities, action ) > -1

    persist_summary_comment_order_to_ror: (conversation_code, comments_order) ->
      #console.log "persist_summary_comment_order_to_ror send order to RoR id: #{conversation_code} with order #{comments_order}"
      $http.post("/api/conversations/#{conversation_code}/summary_comment_order.json", {ordered_ids: comments_order})

    persist_privacy_to_ror: (conversation_code, privacy) ->
      $http.post("/api/conversations/#{conversation_code}/privacy.json", {privacy: privacy})

    persist_tags_to_ror: (conversation_code, tags) ->
      $http.post("/api/conversations/#{conversation_code}/tags.json", {tags: tags})

    persist_schedule_to_ror: (conversation_code, starts_at, ends_at) ->
      $http.post("/api/conversations/#{conversation_code}/schedule.json", {start: starts_at, end: ends_at})

    create_new_conversation: ->
      $http.post("/api/conversations.json")

    publish_conversation: (conversation_code) ->
      $http.post("/api/conversations/#{conversation_code}/publish.json")

    adjust_conversation_bookmark: (action, code, version = 0) ->
      $http[action]("/api/conversations/#{code}/bookmark.json", {version: version})

    guest_posts: (code) ->
      $http.get("/api/conversations/#{code}/guest_posts.json")

    pending_comments: (code) ->
      $http.get("/api/conversations/#{code}/pending_comments.json")

    flagged_comments: (code) ->
      $http.get("/api/conversations/#{code}/flagged_comments.json")

    publish_conversation: (conversation_code) ->
      $http.post("/api/conversations/#{conversation_code}/publish.json")


    accept_guest_post: (post) ->
      $http.post("/api/guest_posts/#{post.id}/accept.json", {accept_join: post.accept_join})

    decline_guest_post: (post) ->
      $http.post("/api/guest_posts/#{post.id}/decline.json", {accept_join: post.accept_join})

    accept_comment: (post) ->
      $http.post("/api/comments/#{post.id}/accept.json")

    decline_comment: (post) ->
      $http.post("/api/comments/#{post.id}/decline.json")

    flag_conversation: (id, version) ->
      $http.post("/api/conversation/#{id}/flag_item.json", {version: version})

    mark_flagged_as: (post,action) ->
      $http.post("/api/flagged_items/#{post.flag_id}/mark_flagged_as.json", {flag_action: action})

    send_invite: (invite, conversation_code) ->
      $http.post("/api/conversations/#{conversation_code}/invite.json", invite)

    invited_guests: (code) ->
      $http.get("/api/conversations/#{code}/invited_guests.json")

    participants_roles: (code) ->
      $http.get("/api/conversations/#{code}/participants_roles.json")

    update_role: (conversation_code, user_code, role) ->
      $http.post("/api/conversations/#{conversation_code}/update_role.json", {user_code: user_code, role: role} )

    load_stats: (conversation_code) ->
      $http.get("/api/conversations/#{conversation_code}/stats.json")
]

services.factory "CommentData", ["$log", "$http", "Comment", "$rootScope",
  ($log, $http, Comment, $rootScope) ->
    name: "CommentData"

    history: (comment_id) ->
      console.log "Retrieve history for comment #{comment_id}"
      $http.get("/api/comments/#{comment_id}/history").then (response) ->
        response.data

    create_in_ror: (action, data) ->
      if action == 'update'
        method = 'put'
        url = "/api/comments/#{data.id}.json"
      else
        method = 'post'
        url = "/api/conversations/#{data.conversation_code}/comments.json"
      #console.log "method: #{method}, url: #{url}"
      $http[method](url, data)

    persist_rating_to_ror: (comment_id, rating) ->
      #console.log "send rating to RoR id: #{comment_id} with rating #{rating}"
      $http.post("/comments/#{comment_id}/rate/#{rating}.json")

    get_comment: (id) ->
      $http.get("/api/comments/#{id}")

    get_comments: (ids) ->
      $http.get("/api/comments?ids=#{ids.join(',')}")

    adjust_comment_bookmark: (action, id, version = 0) ->
      $http[action]("/api/comments/#{id}/bookmark.json", {version: version})

    set_comment_body_template_url: (published, status) ->
      switch
        when published == true then "default"
        when status is "pre-review" then "<%= path_to_asset 'comment-pre-review-body.html' %>"
        when status is "declined" then "<%= path_to_asset 'comment-declined-body.html' %>"
        when status is "deleted" then "<%= path_to_asset 'comment-deleted-body.html' %>"
        when status is "redacted" then "<%= path_to_asset 'comment-redacted-body.html' %>"
        else "default"

    flag_comment: (id, version) ->
      $http.post("/api/comments/#{id}/flag_item.json", {version: version})

    autosave: (data) ->
      #console.log "autosave the comment data"
      $http.post("/autosave.json", {data: data})

    load_autosaved: (data) ->
      #console.log "load_autosaved for the comment data"
      $http.get("/load_autosaved.json", {data: data})

    clear_autosaved: (data) ->
      $http.post("/clear_autosaved.json")

]

# The controllers are responsible for requesting their data and storing it to scope
# The data is requested from a service
# In the callback, the controllers assigns the data to a scope object
# The models are updated from internal posts and external updates the same way
# e.g. when a comment is posted to the server it is also displayed locally by
# by broadcasting an update
# The controllers registers listeners for events that relate to their scope data
# When the controller receives an event notification about its scope data, it updates its collection
# using FirebaseService.process_update(item_array, data)
# Updates from firebase are also added to the bound data
# When child_added is detected, the event is broadcast with the data
# again, the controller listens for the event and then calls FirebaseService.process_update(item_array, data)
# These updates are generated by RoR posting the update to firebase which then
# delivers it to the subscribed clients
# My local post will be processed into the model data twice, once after posting to RoR
# and a second time when RoR sends update to Firebase which sends update to all subscribers
# The updates are idempotent, so multiple updates don't matter

services.factory "FirebaseService", [ "$timeout", "$rootScope", "CommentData", ($timeout, $rootScope, CommentData ) ->
  name: "FirebaseService"
  initialize_source: (url, token) ->
    #console.log "Firebase.initialize_source a new Firebase Update Source with"
    #console.log "firebase url: #{url}"
    #console.log "firebase token: #{token}"
    conversation_updates_ref = new Firebase(url);
    conversation_updates_ref.auth( token )
    conversation_updates_ref.on 'child_added', (data) ->
      data = data.val()
      #console.log "Firebase $broadcast #{data.val().class}_update"
      update_all = false
      if update_all || (Date.fromISO(data.updated_at).getTime() / 1000 ) - $rootScope.timestamp > 0
        $rootScope.$broadcast( "#{data.class}_update", data )
      #else
      #  console.log "Ignore this old update"

  process_update: (item_array, data) ->
    # Only apply updates newer than the page load time
    update_all = false
    if update_all || (Date.fromISO(data.updated_at).getTime() / 1000 ) - $rootScope.timestamp > 0
      if data.action == "delete"
        for rec, index in item_array
          if rec.id == data.data.id
            return item_array.splice(index, 1)
      else
        new_rec = data.data
        #console.log "looking at data with id: #{new_rec.id} and text: #{new_rec.text}"
        for rec, index in item_array
          if rec.id == new_rec.id
            original_rec = angular.copy(item_array[index])
            updated_rec = item_array[index]
            updated_rec[prop] = new_rec[prop] for prop of new_rec when not prop.match(/^\$/)
            updated_rec.reply_to_targets = new_rec.reply_to_targets
            new_rec = null
            update_reply_data(updated_rec,original_rec.reply_to_targets)
            updated_rec.body_template_url = CommentData.set_comment_body_template_url(updated_rec.published, updated_rec.status)
            break
        if new_rec
          new_obj = {}
          new_obj[prop] = new_rec[prop] for prop of new_rec when not prop.match(/^\$/)
          item_array.push new_obj
          update_reply_data(new_obj)
      $rootScope.$$phase || $rootScope.$apply();
    [original_rec, updated_rec]
]
update_reply_data = (new_rec, old_reply_to_targets = null) ->
  if new_rec && new_rec.reply_to_targets # create in_reply_tag from reply_to_targets
    new_rec.in_reply_tag = reply for reply in new_rec.reply_to_targets when reply.quote is false
    # upate the replies[] for targets referenced here
    for target in new_rec.reply_to_targets
      #console.log "add reply to replies for id: #{target.id}"
      target_rec = find_comment_in_conversation(target.id)
      if target_rec
        #console.log "found target_rec with id: #{target_rec.id} and replies: #{target_rec.replies}"
        # add this reply to target_rec, if it isn't already there
        cur_reply = reply for reply in target_rec.replies when reply.id is new_rec.id
        if not cur_reply
          target_rec.replies.push {id:new_rec.id, version: new_rec.version}


  if old_reply_to_targets && old_reply_to_targets.length > 0 # remove unused replies from targets
    # is there an old reply target that is not a new reply target? If so, remove from target replies
    #console.log "check for and remove unused old replies"
    for old_target in old_reply_to_targets
      cur_target = new_target for new_target in (new_rec.reply_to_targets||[]) when new_target.id is old_target.id
      if not cur_target
        #console.log "remove this reply from target is: #{old_target.id}"
        target_rec = find_comment_in_conversation(old_target.id)
        # remove this reply from target_rec.replies
        for reply, index in (target_rec.replies||[])
          if reply.id is new_rec.id
            #console.log "remove this entry from replies"
            target_rec.replies.splice(index,1)

find_comment_in_conversation = (id) ->
  # find the comment in any of the arrays I use
  #console.log "find_comment_in_conversation with id: #{id}"
  conversation = angular.element(document.getElementById('conversation')).scope().conversation
  for source in ['conversation_comments','summary_comments','call_to_action_comment']
    item_array = conversation[source]
    if !angular.isArray(item_array)
      item_array = [item_array]
    #console.log "Check in #{source} with length: #{item_array.length}"
    for item in item_array
      #console.log "Checking item with id: #{item.id}"
      if item.id is id
        return item



services.factory "TemplateEngine",
  ($rootScope, $templateCache, $http, $interpolate) ->
    name: "TemplateEngine"
    interpolation_fns: {}

    interpolate: (templateName, args) ->
      #console.log "TemplateEngine.compile with templateName: #{templateName}"

      # get the interplotion function from a cache
      interpolate_fn = this.interpolation_fns[templateName]

      if interpolate_fn
        # use the cached interpolation function to convert the quote data into html
        return interpolate_fn(args)

      else
        # if not existing, get the template and create the function and store in cache
        #template = $templateCache.get("/assets/angular-views/#{templateName}.html")
        template = $templateCache.get("<%= path_to_asset "quote.html" %>")

        if template
          interpolate_fn = $interpolate(template[1])
          this.interpolation_fns[templateName] = interpolate_fn
          return interpolate_fn(args)

        else
          # I have to intentionally load the template in app.run() with
          # $http.get("/assets/angular-views/quote.html", {cache:$templateCache};)
          # my attempts to load the template when I realize I need cause problems
          # of deep iteration.
          # $broadcast/$on is tightly coupled leading to the same deep iteration
          #$rootScope.$broadcast('load_template',templateName)
          ## load the required template to cache and it will be used next time
          #console.log "load the template for #{templateName}"
          ##$http.get("/assets/angular-views/#{templateName}.html", {cache:$templateCache};)
          ##$http.get("/assets/angular-views/#{templateName}.html")
          return "Initializing TemplateEngine for #{templateName}"


services.factory "ThemeData", ["$http",
  ($http) ->
    name: "ThemeData"

    conversation_theme_data: (conversation_code) ->
      $http.get("/api/conversations/#{conversation_code}/theme_data.json").then (response) ->
        if response.status is 200
          #data: response.data
          theme_comments = []
          table_comments = []
          #authors = {}
          for comment in response.data.displayed_comments
            switch comment.type
              when "ThemeComment" then theme_comments.push comment
              when "TableComment" then table_comments.push comment
          sorted_table_comments = table_comments.sort((a,b)-> a.id - b.id)

          #when "TitleComment" then title_comment = comment
          #when "CallToActionComment" then call_to_action_comment = comment
          #  authors[comment.name] = comment.code
          #authors = ( {name: name, photo_code: authors[name]} for name of authors when name != 'Unconfirmed_User')
          #
          ##console.log "conversation_id: #{conversation_id}"
          ## extract and setup some data for the directive controller
          tag_hash = {}
          for comment in theme_comments
            tag_hash[comment.id] = comment.tag_name

          table_comments: sorted_table_comments
          theme_comments: theme_comments.sort((a,b)-> a.id - b.id)
          filtered_table_comments: sorted_table_comments
          theme_tag_hash: tag_hash
          title: response.data.title
          code: response.data.code
          current_timestamp: response.data.current_timestamp
          privacy: response.data.privacy
          abilities: response.data.role.abilities
          can: (action) ->
            _.indexOf(this.abilities, action ) > -1


    #firebase_token: response.data.firebase_token
    #summary_comments: summary_comments.sort((a,b)-> a.order_id - b.order_id)
    #conversation_comments: conversation_comments.sort((a,b)-> a.order_id - b.order_id)
    #title_comment: title_comment
    #call_to_action_comment: call_to_action_comment || {
    #editable_by_user: true
    #id: 0
    #purpose: "Call to action"
    #text: "This area is for your call-to-action. Here you describe this conversation and suggest ways for people to contribute."
    #type: "CallToActionComment"
    #updated_at: new Date()
    #version: 0
    #}

    #tags: response.data.tags.sort()
    #starts_at: new Date(response.data.starts_at)
    #ends_at: new Date(response.data.ends_at)
    #published: response.data.published
    #list: response.data.list
    #status: response.data.status
    #notification_request  : response.data.notification_request
    #participants: authors
    #role: response.data.role.name
    #abilities: response.data.role.abilities
    #can: (action) ->
    #  _.indexOf(this.abilities, action ) > -1


    create_new_theme: (data) ->
      $http.post("/api/conversations/#{data.conversation_code}/comments.json", data)

    save_theme_assignment: (data) ->
      $http.post("/api/comments/#{data.comment_id}/assign_themes.json", { theme_ids: data.theme_ids})

]